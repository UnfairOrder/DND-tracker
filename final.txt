Michael Leoni
CSCI 200 - Section B
DnD Character Creator

PROBLEM DESCRIPTION:
    I wanted to make a character creator for dnd, and the end goal was to implement a play functionality that would allow the user to track abilities and roll dice virtually for those abilities.

DOCUMENTAITON:
    Running and using the program is rather simple - Upon execution the user will be prompted with a menu that allows them to either load pre-saved characters, 
    create a new character or view currently loaded characters, or quit the program. Quitting the program saves the pre-loaded characters.

    The main functionality of the program as of now is creating the characters, which is extremely basic and lacks much of the nuance that DnD actually has for it's character creation.
    Nonetheless, the user is first prompted with some classes they can choose from. At the moment there are only 2 classes, but adding more is trivial. Within the Classes.h and .cpp files
    There are the implementations of both the character classes. The reason these are classes and not structs is becase we hadn't learned about structs when I started working on this.

    Each class object contains some basic information about the class, including the classes' name, hit dice, description, some proficiencies for weapons and armor, skill proficiencies, and saving throw profieicies.
    Creating a new class or implementing more classes is a simple as adding an extern declaration of the class to the header file, adding that extern declaration to the classlist vector,
    and then creating the implementation of the class in the .cpp file.

    After picking a class, which is displayed at the top of the screen as character creation continues, the user is asked to enter a race for their character. This could be something like elf, dwarf
    human, orc, half orc, etc. While this should have an impact on the character itself in terms of stats, I made the choice to delay implementing it as it would be no different than the class implementation.
    I wanted to work on other things, so in reality, the user can enter anything they want into this field, and the program will take it.

    At this point the user gets to pick their character stats. I wanted to have a interesting and novel interface for how this was done, so this took a ton more time than I wanted it to.
    The user is presented with a set of random numbers that are generated by rolling 4 d6 dice, and dropping the lowest. They are prompted to pick which number they would like to be each stat.
    Using the arrow keys, the user can move the pointer from side to side, and select by hitting enter. Upon assigning all the stats they can either confirm or re assign the stats. However, should they
    choose to re assign, the numbers stay the same.

    At this point the user is prompted for height, and then the character's name, and the character is created as an object and loaded into memory.

    The Character
        The character class contains a ton of data that is mostly accessible by getters and setters. was this smart? no. did I know what I was doing at the time? also no. so it is what it is
        it contains data about the character's total health, their skill proficiencies, their saving throw modifiers, and the hope was to include items and abilities as well.

    Saving and Loading characters
        Upon quitting the function Each Character is saved to their namesake file, and their name is stored in a saved_characters.txt. I thought about adding some means of encryption or error correcting
        to the save files, and then realized that would be an intriguing but ultimatley unproductive use of my time with regards to the project guidelines. The basic info for the character constructor function is saved,
        so that the file can rather simply be read and out pops a character object. The method for this exists in main in fact.

    Items and what could've been
        I had a ton of ambition coming into this project, and I would've loved to work more on this but life gets busy. The original proposal deviated so far from what there is now, it's likely not really worth looking at.
        There are some similarities if you squint, but for the most part I've been refactoring what I've done as we learned new things in class, sometimes even implementing things that aren't needed purely for the sake of playing with them.
        However, the final vision of the project was one where you could create characters, and then view them in the game menu option. In the game menu option, the user would be able to perform attack rolls, skill checks,
        cast spells, manage their inventory, take damage, and potentially die. At one point I even played with how I would theoretically get an sfml implementation for a game board to work, much like L6C. With that alternate idea came
        the possibility of spell or item targetting differences.

        I digress. As far as I got with the further implementation was creation of an item interface, and a weapon interface that contained a ranged weapon and melee weapon concrete implementation. Because all of these extend the item
        interface, it would be rather simple to make a function that calls a virtual use function on the item interface in order to access each weapon's individual and different abilities through the same implementation.

        There also was the idea to implement an ability interface that would be the superclass of either class abilities or spells that the player could then use. This too would contain a virtual use method that would then be implemented
        in all the child classes, each of which would correspond to their own spell or ability. Then, a list of these abilities would exist inside the character object that the user could select from in the game menu
        option. At this point the virtual use method would get called, and this use method would parse the character calling it as a parameter by reference or by pointer, and that character would then effecitvley use the spell or ability.
        This is where a function pointer for targetting types would come in as well, but again, didn't get that far.

CLASS DESCRIPTION:
    I made two main custom classes for this project, each with varying levels of actual function or simply data storage. The bulkiest and most important of them is the character class.
    The character class contains all of the data for the character, including methods that generate the stats for the character randomly, the constructor that populates the skill map,
    and ultimatley it contains the function to save the character to a file, and the character.cpp file contains the function to load a character from a file. I'll be the first to admit
    this class doesn't contain a huge amount of functional methods, just the heal and damage methods that can't be used and the calculate max hp function, and maybe the save funciton if you're willing to count that. The plan was to have
    more than that, but this was just how the cookie crumbled.

    The second custom class I created was the PlayerClass class. This class was meant to simply contain the information for each individual class. It could've been a struct, but as stated earlier,
    I got too far in to go back and change things.

LIST DATA STRUCTURE:
    I chose to use a linked list for the inventory in the Character object, this is because I could have the node structure contain both a pointer to an Item and a quantity of items.
    This meant that I could still do runtime polymorphism and have the quantity of the items in each slot, so it was perfect. However the implementaiton is no more than just
    declaring the inventory object in the constructor for the character, and then populating it with a dagger and a longbow, the only two items that I added.

    I also use a ton of vectors. Just... tons of them.

FILE I/O:
    File I/O was implemented for the character saving and loading, obviously. In the context of the final vison of the program, yes this was a neccessary step. However, in it's current 
    state there's literally no reason to use this program because frankly it can't do anything. So it's not neccessary as of now, but it could be useful should i keep working on the program.

REFLECTIONS:
    I learned a ton from working on this project. Probably more than I did from many of the assignments. I think I bit off more than i could chew, a common habit of mine unfortunatley,
    but I had a vison for a final version of this project that I wanted to work towards, requirements be damned until the last minute unfortunatley. However, the breadth of the project
    forced me to stop and think about how I wanted to implement many of the features before working on them, rather than haphazardly coding and fixing things later; It made me code with future
    additions in mind rather than creating some singular and stagnant program. If I had to do another project, I think I'd just keep working on this. In fact, I think I'm going to keep working on
    this regardless of if there's another project or not.




    